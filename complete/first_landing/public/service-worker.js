// // service-worker.js

// // Import the Workbox library from a CDN
// importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');

// if (workbox) {
//   console.log(`Workbox is loaded!`);

//   // Precache all of the assets generated by your build process.
//   // These URLs are injected into the manifest by Workbox's build process.
//   workbox.precaching.precacheAndRoute([
//     { url: '/index.html', revision: '1' },
//     { url: '/manifest.json', revision: '1' },
//     { url: '/favicon.ico', revision: '1' },
//     { url: '/android-chrome-192x192.png', revision: '1' },
//     { url: '/android-chrome-512x512.png', revision: '1' },
//     // Add other static assets that you want to precache
//   ]);

//   // Cache the Google Fonts stylesheets and webfont files,
//   // for a year in a stale-while-revalidate strategy.
//   workbox.routing.registerRoute(
//     ({url}) => url.origin === 'https://fonts.googleapis.com' ||
//                url.origin === 'https://fonts.gstatic.com',
//     new workbox.strategies.StaleWhileRevalidate({
//       cacheName: 'google-fonts',
//       plugins: [
//         new workbox.expiration.ExpirationPlugin({
//           maxEntries: 50,
//           maxAgeSeconds: 60 * 60 * 24 * 365,
//         }),
//       ],
//     }),
//   );

//   // Use a "StaleWhileRevalidate" strategy for assets like CSS, JS, and images
//   workbox.routing.registerRoute(
//     ({request}) => request.destination === 'style' ||
//                   request.destination === 'script' ||
//                   request.destination === 'image',
//     new workbox.strategies.StaleWhileRevalidate({
//       cacheName: 'static-assets',
//       plugins: [
//         new workbox.expiration.ExpirationPlugin({
//           maxEntries: 60,
//           maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
//         }),
//       ],
//     }),
//   );

//   // Fallback for offline pages
//   workbox.routing.setCatchHandler(({event}) => {
//     switch (event.request.destination) {
//       case 'document':
//         return caches.match('/index.html');
//       default:
//         return Response.error();
//     }
//   });


//   // --- Advanced Feature: Background Sync for Contact Form ---

//   // This will catch failed POST requests for your contact form.
//   // You will need to change '/api/contact/' to your actual Django endpoint.
//   const backgroundSyncQueue = new workbox.backgroundSync.BackgroundSyncPlugin('contactFormQueue', {
//       maxRetentionTime: 24 * 60, // Retry for a day
//   });

//   workbox.routing.registerRoute(
//     new RegExp('/api/contact/'), // Replace with your Django contact form endpoint
//     new workbox.strategies.NetworkOnly({
//       plugins: [backgroundSyncQueue],
//     }),
//     'POST'
//   );
//   // --- End of Background Sync Feature ---

// } else {
//   console.log(`Workbox failed to load.`);
// }


// // service-worker.js
// importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');

// if (workbox) {
//   console.log(`Workbox is loaded!`);

//   workbox.precaching.precacheAndRoute([
//     { url: '/', revision: '1' },
//     { url: '/index.html', revision: '1' },
//     { url: '/manifest.json', revision: '1' },
//     { url: '/favicon.ico', revision: '1' },
//     { url: '/android-chrome-192x192.png', revision: '1' },
//     { url: '/android-chrome-512x512.png', revision: '1' },
//     { url: '/robots.txt', revision: '1' },
//     { url: '/IMG-20250730-WA0011.jpg', revision: '1' }
//   ]);

//   // Styles, Scripts, Images
//   workbox.routing.registerRoute(
//     ({request}) => (
//       request.destination === 'style' ||
//       request.destination === 'script' ||
//       request.destination === 'image'
//     ),
//     new workbox.strategies.StaleWhileRevalidate({
//       cacheName: 'static-assets',
//       plugins: [
//         new workbox.expiration.ExpirationPlugin({
//           maxEntries: 60,
//           maxAgeSeconds: 60 * 60 * 24 * 30,
//         }),
//       ],
//     }),
//   );

//   // Google Fonts
//   workbox.routing.registerRoute(
//     ({url}) =>
//       url.origin === 'https://fonts.googleapis.com' ||
//       url.origin === 'https://fonts.gstatic.com',
//     new workbox.strategies.StaleWhileRevalidate({
//       cacheName: 'google-fonts',
//       plugins: [
//         new workbox.expiration.ExpirationPlugin({
//           maxEntries: 50,
//           maxAgeSeconds: 60 * 60 * 24 * 365,
//         }),
//       ],
//     }),
//   );

//   // SPA routing
//   workbox.routing.registerRoute(
//     ({ request }) => request.mode === 'navigate',
//     new workbox.strategies.NetworkFirst({
//       cacheName: 'navigation',
//       plugins: [
//         new workbox.expiration.ExpirationPlugin({
//           maxEntries: 50,
//           maxAgeSeconds: 60 * 60 * 24 * 30,
//         }),
//       ],
//     })
//   );

//   // Fallback for offline pages
//   workbox.routing.setCatchHandler(({event}) => {
//     switch (event.request.destination) {
//       case 'document':
//         return caches.match('/');
//       default:
//         return Response.error();
//     }
//   });

//   // -- Background sync for contact form --
//   const contactFormQueue = new workbox.backgroundSync.BackgroundSyncPlugin('contactFormQueue', {
//     maxRetentionTime: 24 * 60,
//     onSync: async ({queue}) => {
//       let entry;
//       while ((entry = await queue.shiftRequest())) {
//         try {
//           await fetch(entry.request);
//           console.log('Contact form successfully sent after reconnecting');
//         } catch (err) {
//           await queue.unshiftRequest(entry);
//           throw err;
//         }
//       }
//     }
//   });

//   // *** Use this route if your frontend can POST to /api/contact/submit/ through Netlify ***
//   workbox.routing.registerRoute(
//     /\/api\/contact\/submit\//,
//     new workbox.strategies.NetworkOnly({
//       plugins: [contactFormQueue],
//     }),
//     'POST'
//   );
// }
// else {
//   console.log(`Workbox failed to load.`);
// }
// service-worker.js

// service-worker.js

// service-worker.js

importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');

if (workbox) {
  console.log(`Workbox is loaded!`);

  // Precache all critical assets
  workbox.precaching.precacheAndRoute([
    { url: '/', revision: '1' },
    { url: '/index.html', revision: '1' },
    { url: '/manifest.json', revision: '1' },
    { url: '/favicon.ico', revision: '1' },
    { url: '/android-chrome-192x192.png', revision: '1' },
    { url: '/android-chrome-512x512.png', revision: '1' },
    { url: '/robots.txt', revision: '1' },
    { url: '/IMG-20250730-WA0011.jpg', revision: '1' },
  ]);

  // Navigation strategy
  workbox.routing.registerRoute(
    ({ request }) => request.mode === 'navigate',
    new workbox.strategies.NetworkFirst({
      cacheName: 'navigation',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 60 * 60 * 24 * 30,
        }),
      ],
    })
  );

  // Cache static assets
  workbox.routing.registerRoute(
    ({request}) => request.destination === 'style' ||
                  request.destination === 'script' ||
                  request.destination === 'image',
    new workbox.strategies.StaleWhileRevalidate({
      cacheName: 'static-assets',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 60 * 60 * 24 * 30,
        }),
      ],
    }),
  );

  // Enhanced Background Sync for Contact Form
  let queuedRequests = [];

  const contactFormQueue = new workbox.backgroundSync.BackgroundSyncPlugin('contactFormQueue', {
    maxRetentionTime: 24 * 60, // Retry for 24 hours
    onSync: async ({queue}) => {
      let entry;
      let successCount = 0;
      let failCount = 0;
      
      console.log('Processing queued contact form submissions...');
      
      while ((entry = await queue.shiftRequest())) {
        try {
          const response = await fetch(entry.request.clone());
          
          if (response.ok) {
            successCount++;
            console.log('Contact form submitted successfully after being queued');
            
            // Notify the main thread about successful submission
            self.clients.matchAll().then(clients => {
              clients.forEach(client => {
                client.postMessage({
                  type: 'SUBMISSION_SUCCESS',
                  data: { timestamp: new Date().toISOString() }
                });
              });
            });
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          failCount++;
          console.error('Failed to submit contact form:', error);
          
          // Re-queue the request if it fails
          await queue.unshiftRequest(entry);
          
          // Notify the main thread about failed submission
          self.clients.matchAll().then(clients => {
            clients.forEach(client => {
              client.postMessage({
                type: 'SUBMISSION_FAILED',
                error: error.message
              });
            });
          });
          
          throw error;
        }
      }
      
      console.log(`Processed queued submissions: ${successCount} successful, ${failCount} failed`);
      
      // Update queue status
      updateQueueStatus();
    }
  });

  // Function to update queue status
  const updateQueueStatus = async () => {
    try {
      const db = await workbox.backgroundSync._queueNames.get('contactFormQueue');
      if (db) {
        const count = await db.size();
        self.clients.matchAll().then(clients => {
          clients.forEach(client => {
            client.postMessage({
              type: 'QUEUE_STATUS',
              count: count
            });
          });
        });
      }
    } catch (error) {
      console.error('Error updating queue status:', error);
    }
  };

  // Register route for contact form submissions
  workbox.routing.registerRoute(
    new RegExp('/api/contact/submit/'),
    new workbox.strategies.NetworkOnly({
      plugins: [contactFormQueue],
    }),
    'POST'
  );

  // Listen for messages from the main thread
  self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'PROCESS_QUEUE') {
      // Force background sync to process queue
      self.registration.sync.register('contactFormQueue').then(() => {
        console.log('Background sync registered to process queue');
      }).catch(error => {
        console.error('Failed to register background sync:', error);
      });
    } else if (event.data && event.data.type === 'GET_QUEUE_STATUS') {
      updateQueueStatus();
    }
  });

  // Handle background sync events
  self.addEventListener('sync', (event) => {
    if (event.tag === 'contactFormQueue') {
      console.log('Background sync triggered for contact form queue');
      event.waitUntil(
        // The BackgroundSyncPlugin will handle this automatically,
        // but we can add additional logic here if needed
        Promise.resolve()
      );
    }
  });

  // Enhanced online event handler
  self.addEventListener('online', () => {
    console.log('Service worker detected online event');
    // Trigger background sync when coming back online
    self.registration.sync.register('contactFormQueue').catch(error => {
      console.error('Failed to register background sync on online event:', error);
    });
  });

  // Fallback for offline pages
  workbox.routing.setCatchHandler(({event}) => {
    switch (event.request.destination) {
      case 'document':
        return caches.match('/');
      default:
        return Response.error();
    }
  });

  // Installation and activation events
  self.addEventListener('install', (event) => {
    console.log('Service worker installing...');
    self.skipWaiting();
  });

  self.addEventListener('activate', (event) => {
    console.log('Service worker activating...');
    event.waitUntil(self.clients.claim());
  });

} else {
  console.log(`Workbox failed to load.`);
}

// Install Event: Cache all the necessary files
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('Cache opened, adding all static assets.');
        // Add all URLs to the cache. Handle any individual failures gracefully.
        return Promise.all(
          urlsToCache.map(url => {
            return cache.add(url).catch(error => {
              console.warn(`Failed to cache ${url}: ${error}`);
            });
          })
        );
      })
      .then(() => self.skipWaiting())
      .catch(error => console.error('Service Worker installation failed:', error))
  );
});

// Fetch Event: Serve from cache first, then fall back to the network
self.addEventListener('fetch', (event) => {
  // Ignore non-GET requests and requests for external domains
  if (event.request.method !== 'GET' || !event.request.url.startsWith(self.location.origin)) {
    return;
  }
  
  event.respondWith(
    caches.match(event.request).then(response => {
      // If a cached version exists, return it immediately
      if (response) {
        return response;
      }
      
      // If not in cache, fetch from the network
      return fetch(event.request).then(networkResponse => {
        // Cache new successful responses for future use
        if (networkResponse && networkResponse.status === 200) {
          const responseToCache = networkResponse.clone();
          caches.open(CACHE_NAME).then(cache => {
            cache.put(event.request, responseToCache);
          });
        }
        return networkResponse;
      });
    }).catch(() => {
      // Fallback for when both cache and network fail (e.g., an offline page)
      // return caches.match('/offline.html');
      return new Response('You are offline. The requested content is not available.');
    })
  );
});

// Activate Event: Clean up old caches
self.addEventListener('activate', (event) => {
  const cacheWhitelist = [CACHE_NAME];
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!cacheWhitelist.includes(cacheName)) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
    .then(() => self.clients.claim())
  );
});